N = Next thing to do
* = ?
L = Later

Generic stuff
-------------
N Clean up in deaemon_log and dbg_log macro usage.
N Update example curl usage in code
L Write documentation (Use LyX)
  - A White paper
  - End-user guide (client and server users)
N Ask Per to contribute the delayed start patch to the Erlang distro.
  _ Verify that we use it ok, i.e. for common_config_json_serv errors
L Add package management support for:
  - Ubuntu
  - Mac
  - Windows
L Setup a nice anond site
L Implement anond control panels for:
  - GTK
  - Mac
  - Windows

Directory server
----------------
* Test that it all works. :-)
* Make it possible to register a "domain"-name for a bunch of overlay
adresses. The registration could be done through the directory
server. Name lookups could be done towards a UDP based overlay service.

Node
----
N Start to use the PKI to encrypt tunnel traffic
  - handshake, rethinkg directory server get_node(). needed? etc
  - call ds_serv:get_node (renamed to get_public_key?)
  -  http://en.wikipedia.org/wiki/UDP_hole_punching



A >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DS
  jsonrpc/ssl: publish_node(node_public_key) -> {id, ip}
  store: {unique_id, ip} -> public_key
A >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DS
  jsonrpc/ssl: get_random_nodes(unique_id, ip, n) ->
                   [{neighbour_id, neighbour_ip, public_key}]
A >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DS
  binary/cryptobox: node_handshake
    {unique_id, ip, neighbour_b_id, neighbour_b_ip}
  note: send until an node_handshake_ack arrives from DS



A >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DS
  jsonrpc/ssl: publish_node(node_public_key) ->
                   {unique_id, ds_public_key}


A <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< DS


    note: ds now stores the mapping:
      unique_id -> {node_ip_address, node_public_key}
A -> DS:
  udp/cryptobox hail packet (signed with node_private_key)
    note: ds now know the external UDP port for A
    note: sends a hail packet until DS sends a hail_ack back
DS -> A
  hail_ack
      unique_id -> {node_ip_address, node_port, node_public_key}
A ->


A:
has been published
1) publish



N Integrate Patrik's psp code and authentication of path costs code
N Many oas per na (add random generation of oas as an alternative to
static as well)
N TCP node punching to directory server
N Chop large route entries ito 1024 packets
* Test that it all works. :-)
* Limit download and upload rate in B/s
* Use many overlay addresses and pick new ones now and then
* Pick new neighbour nodes now and then when needed(TM)

d3.js
-----
* Leaks memory
* Try to normalize the path-cost <-> pixel resolution
* Does it actually work in all cases when nodes come and go?

DNS
---
* Investigate how to intercept DNS traffic (port 53) on the end-user
machine using something such as https://gnunet.org/book/export/html/1631 and
http://blog.listincomprehension.com/2010/07/dns-programming-with-erlang.html.

Hardware setup
--------------
N Buy a really big machine with 128GB RAM and setup 50 Ubuntu
servers. Run a bittorrent tracker on one of them and let the rest of
them download/seed files.

Tuncer
------
L Add ioctl calls for all "ifconfig" calls to remove the need to give
root access to beam.smp, e.g. it should be enough use setcap on Linux
L Make tuncer:read/2 work
L Make it run on Windows
